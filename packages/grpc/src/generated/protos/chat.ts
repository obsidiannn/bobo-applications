// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.19.1
// source: protos/chat.proto

/* eslint-disable */
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { BoolValue } from "../google/protobuf/wrappers.js";

export const protobufPackage = "chat_proto";

export enum MessageType {
  TEXT = 0,
  IMAGE = 1,
  VIDEO = 2,
  FILE = 3,
  LINK = 4,
  UNRECOGNIZED = -1,
}

export function messageTypeFromJSON(object: any): MessageType {
  switch (object) {
    case 0:
    case "TEXT":
      return MessageType.TEXT;
    case 1:
    case "IMAGE":
      return MessageType.IMAGE;
    case 2:
    case "VIDEO":
      return MessageType.VIDEO;
    case 3:
    case "FILE":
      return MessageType.FILE;
    case 4:
    case "LINK":
      return MessageType.LINK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MessageType.UNRECOGNIZED;
  }
}

export function messageTypeToJSON(object: MessageType): string {
  switch (object) {
    case MessageType.TEXT:
      return "TEXT";
    case MessageType.IMAGE:
      return "IMAGE";
    case MessageType.VIDEO:
      return "VIDEO";
    case MessageType.FILE:
      return "FILE";
    case MessageType.LINK:
      return "LINK";
    case MessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Chat {
  id: string;
  creatorId: bigint;
  lastSequence: bigint;
  businessType: number;
  createdAt: bigint;
  updatedAt: bigint;
}

export interface Message {
  id: string;
  chatId: string;
  senderId: bigint;
  senderType: number;
  sequence: bigint;
  createdAt: bigint;
  updatedAt: bigint;
  deletedAt: bigint;
}

export interface FindByIdsRequest {
  ids: string[];
}

export interface ChatListResponse {
  chats: Chat[];
}

export interface RemoveUserRequest {
  id: string;
  userIds: bigint[];
}

export interface RemoveUserByIdsRequest {
  ids: string[];
  userId: bigint;
}

export interface RemoveUserByUserIdsRequest {
  userIds: bigint[];
}

export interface ChangeCreatorRequest {
  id: string;
  creatorId: bigint;
}

export interface SendUserMessageRequest {
  id: string;
  userId: bigint;
  type: MessageType;
  content: string;
  receiverUserIds: bigint[];
  msgId: string;
}

export interface SendBotMessageRequest {
  id: string;
  senderId: bigint;
  type: MessageType;
  content: string;
  msgId: string;
}

export interface SendBotMessageResponse {
  items: Message[];
}

export interface AddUserRequest {
  id: string;
  userIds: bigint[];
}

export interface ExitByIdsRequest {
  ids: string[];
  userIds: bigint[];
}

export interface DropByIdsRequest {
  ids: string[];
}

export interface ClearMessageByIdsRequest {
  ids: string[];
}

export interface ClearMessageByUserIdsRequest {
  userIds: bigint[];
}

export interface CreateRequest {
  /** userId 或 groupId 或 bot Id */
  creatorId: bigint;
  businessType: number;
  userIds: bigint[];
}

export interface ChatConfigRequest {
  id: string;
  userId: bigint;
  changeField: string;
  value: string;
}

export interface ChatConfigResponse {
  id: string;
  isTop: number;
  isMute: number;
  isShow: number;
  isHide: number;
}

function createBaseChat(): Chat {
  return { id: "", creatorId: 0n, lastSequence: 0n, businessType: 0, createdAt: 0n, updatedAt: 0n };
}

export const Chat = {
  encode(message: Chat, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creatorId !== 0n) {
      if (BigInt.asUintN(64, message.creatorId) !== message.creatorId) {
        throw new globalThis.Error("value provided for field message.creatorId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.creatorId.toString());
    }
    if (message.lastSequence !== 0n) {
      if (BigInt.asUintN(64, message.lastSequence) !== message.lastSequence) {
        throw new globalThis.Error("value provided for field message.lastSequence of type uint64 too large");
      }
      writer.uint32(24).uint64(message.lastSequence.toString());
    }
    if (message.businessType !== 0) {
      writer.uint32(32).int32(message.businessType);
    }
    if (message.createdAt !== 0n) {
      if (BigInt.asUintN(64, message.createdAt) !== message.createdAt) {
        throw new globalThis.Error("value provided for field message.createdAt of type uint64 too large");
      }
      writer.uint32(40).uint64(message.createdAt.toString());
    }
    if (message.updatedAt !== 0n) {
      if (BigInt.asUintN(64, message.updatedAt) !== message.updatedAt) {
        throw new globalThis.Error("value provided for field message.updatedAt of type uint64 too large");
      }
      writer.uint32(48).uint64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Chat {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChat();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.creatorId = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.lastSequence = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.businessType = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.createdAt = longToBigint(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.updatedAt = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chat {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creatorId: isSet(object.creatorId) ? BigInt(object.creatorId) : 0n,
      lastSequence: isSet(object.lastSequence) ? BigInt(object.lastSequence) : 0n,
      businessType: isSet(object.businessType) ? globalThis.Number(object.businessType) : 0,
      createdAt: isSet(object.createdAt) ? BigInt(object.createdAt) : 0n,
      updatedAt: isSet(object.updatedAt) ? BigInt(object.updatedAt) : 0n,
    };
  },

  toJSON(message: Chat): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creatorId !== 0n) {
      obj.creatorId = message.creatorId.toString();
    }
    if (message.lastSequence !== 0n) {
      obj.lastSequence = message.lastSequence.toString();
    }
    if (message.businessType !== 0) {
      obj.businessType = Math.round(message.businessType);
    }
    if (message.createdAt !== 0n) {
      obj.createdAt = message.createdAt.toString();
    }
    if (message.updatedAt !== 0n) {
      obj.updatedAt = message.updatedAt.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chat>, I>>(base?: I): Chat {
    return Chat.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chat>, I>>(object: I): Chat {
    const message = createBaseChat();
    message.id = object.id ?? "";
    message.creatorId = object.creatorId ?? 0n;
    message.lastSequence = object.lastSequence ?? 0n;
    message.businessType = object.businessType ?? 0;
    message.createdAt = object.createdAt ?? 0n;
    message.updatedAt = object.updatedAt ?? 0n;
    return message;
  },
};

function createBaseMessage(): Message {
  return { id: "", chatId: "", senderId: 0n, senderType: 0, sequence: 0n, createdAt: 0n, updatedAt: 0n, deletedAt: 0n };
}

export const Message = {
  encode(message: Message, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.chatId !== "") {
      writer.uint32(18).string(message.chatId);
    }
    if (message.senderId !== 0n) {
      if (BigInt.asUintN(64, message.senderId) !== message.senderId) {
        throw new globalThis.Error("value provided for field message.senderId of type uint64 too large");
      }
      writer.uint32(24).uint64(message.senderId.toString());
    }
    if (message.senderType !== 0) {
      writer.uint32(32).int32(message.senderType);
    }
    if (message.sequence !== 0n) {
      if (BigInt.asUintN(64, message.sequence) !== message.sequence) {
        throw new globalThis.Error("value provided for field message.sequence of type uint64 too large");
      }
      writer.uint32(40).uint64(message.sequence.toString());
    }
    if (message.createdAt !== 0n) {
      if (BigInt.asUintN(64, message.createdAt) !== message.createdAt) {
        throw new globalThis.Error("value provided for field message.createdAt of type uint64 too large");
      }
      writer.uint32(48).uint64(message.createdAt.toString());
    }
    if (message.updatedAt !== 0n) {
      if (BigInt.asUintN(64, message.updatedAt) !== message.updatedAt) {
        throw new globalThis.Error("value provided for field message.updatedAt of type uint64 too large");
      }
      writer.uint32(56).uint64(message.updatedAt.toString());
    }
    if (message.deletedAt !== 0n) {
      if (BigInt.asUintN(64, message.deletedAt) !== message.deletedAt) {
        throw new globalThis.Error("value provided for field message.deletedAt of type uint64 too large");
      }
      writer.uint32(64).uint64(message.deletedAt.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Message {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.chatId = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.senderId = longToBigint(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.senderType = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.sequence = longToBigint(reader.uint64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.createdAt = longToBigint(reader.uint64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.updatedAt = longToBigint(reader.uint64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.deletedAt = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Message {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      chatId: isSet(object.chatId) ? globalThis.String(object.chatId) : "",
      senderId: isSet(object.senderId) ? BigInt(object.senderId) : 0n,
      senderType: isSet(object.senderType) ? globalThis.Number(object.senderType) : 0,
      sequence: isSet(object.sequence) ? BigInt(object.sequence) : 0n,
      createdAt: isSet(object.createdAt) ? BigInt(object.createdAt) : 0n,
      updatedAt: isSet(object.updatedAt) ? BigInt(object.updatedAt) : 0n,
      deletedAt: isSet(object.deletedAt) ? BigInt(object.deletedAt) : 0n,
    };
  },

  toJSON(message: Message): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.chatId !== "") {
      obj.chatId = message.chatId;
    }
    if (message.senderId !== 0n) {
      obj.senderId = message.senderId.toString();
    }
    if (message.senderType !== 0) {
      obj.senderType = Math.round(message.senderType);
    }
    if (message.sequence !== 0n) {
      obj.sequence = message.sequence.toString();
    }
    if (message.createdAt !== 0n) {
      obj.createdAt = message.createdAt.toString();
    }
    if (message.updatedAt !== 0n) {
      obj.updatedAt = message.updatedAt.toString();
    }
    if (message.deletedAt !== 0n) {
      obj.deletedAt = message.deletedAt.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage();
    message.id = object.id ?? "";
    message.chatId = object.chatId ?? "";
    message.senderId = object.senderId ?? 0n;
    message.senderType = object.senderType ?? 0;
    message.sequence = object.sequence ?? 0n;
    message.createdAt = object.createdAt ?? 0n;
    message.updatedAt = object.updatedAt ?? 0n;
    message.deletedAt = object.deletedAt ?? 0n;
    return message;
  },
};

function createBaseFindByIdsRequest(): FindByIdsRequest {
  return { ids: [] };
}

export const FindByIdsRequest = {
  encode(message: FindByIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FindByIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindByIdsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: FindByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindByIdsRequest>, I>>(base?: I): FindByIdsRequest {
    return FindByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindByIdsRequest>, I>>(object: I): FindByIdsRequest {
    const message = createBaseFindByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseChatListResponse(): ChatListResponse {
  return { chats: [] };
}

export const ChatListResponse = {
  encode(message: ChatListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.chats) {
      Chat.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.chats.push(Chat.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatListResponse {
    return { chats: globalThis.Array.isArray(object?.chats) ? object.chats.map((e: any) => Chat.fromJSON(e)) : [] };
  },

  toJSON(message: ChatListResponse): unknown {
    const obj: any = {};
    if (message.chats?.length) {
      obj.chats = message.chats.map((e) => Chat.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatListResponse>, I>>(base?: I): ChatListResponse {
    return ChatListResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatListResponse>, I>>(object: I): ChatListResponse {
    const message = createBaseChatListResponse();
    message.chats = object.chats?.map((e) => Chat.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRemoveUserRequest(): RemoveUserRequest {
  return { id: "", userIds: [] };
}

export const RemoveUserRequest = {
  encode(message: RemoveUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [],
    };
  },

  toJSON(message: RemoveUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserRequest>, I>>(base?: I): RemoveUserRequest {
    return RemoveUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserRequest>, I>>(object: I): RemoveUserRequest {
    const message = createBaseRemoveUserRequest();
    message.id = object.id ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseRemoveUserByIdsRequest(): RemoveUserByIdsRequest {
  return { ids: [], userId: 0n };
}

export const RemoveUserByIdsRequest = {
  encode(message: RemoveUserByIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    if (message.userId !== 0n) {
      if (BigInt.asUintN(64, message.userId) !== message.userId) {
        throw new globalThis.Error("value provided for field message.userId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.userId.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveUserByIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserByIdsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      userId: isSet(object.userId) ? BigInt(object.userId) : 0n,
    };
  },

  toJSON(message: RemoveUserByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.userId !== 0n) {
      obj.userId = message.userId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserByIdsRequest>, I>>(base?: I): RemoveUserByIdsRequest {
    return RemoveUserByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserByIdsRequest>, I>>(object: I): RemoveUserByIdsRequest {
    const message = createBaseRemoveUserByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.userId = object.userId ?? 0n;
    return message;
  },
};

function createBaseRemoveUserByUserIdsRequest(): RemoveUserByUserIdsRequest {
  return { userIds: [] };
}

export const RemoveUserByUserIdsRequest = {
  encode(message: RemoveUserByUserIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveUserByUserIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveUserByUserIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveUserByUserIdsRequest {
    return { userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [] };
  },

  toJSON(message: RemoveUserByUserIdsRequest): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveUserByUserIdsRequest>, I>>(base?: I): RemoveUserByUserIdsRequest {
    return RemoveUserByUserIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveUserByUserIdsRequest>, I>>(object: I): RemoveUserByUserIdsRequest {
    const message = createBaseRemoveUserByUserIdsRequest();
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseChangeCreatorRequest(): ChangeCreatorRequest {
  return { id: "", creatorId: 0n };
}

export const ChangeCreatorRequest = {
  encode(message: ChangeCreatorRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.creatorId !== 0n) {
      if (BigInt.asUintN(64, message.creatorId) !== message.creatorId) {
        throw new globalThis.Error("value provided for field message.creatorId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.creatorId.toString());
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChangeCreatorRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChangeCreatorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.creatorId = longToBigint(reader.uint64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChangeCreatorRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      creatorId: isSet(object.creatorId) ? BigInt(object.creatorId) : 0n,
    };
  },

  toJSON(message: ChangeCreatorRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.creatorId !== 0n) {
      obj.creatorId = message.creatorId.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChangeCreatorRequest>, I>>(base?: I): ChangeCreatorRequest {
    return ChangeCreatorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChangeCreatorRequest>, I>>(object: I): ChangeCreatorRequest {
    const message = createBaseChangeCreatorRequest();
    message.id = object.id ?? "";
    message.creatorId = object.creatorId ?? 0n;
    return message;
  },
};

function createBaseSendUserMessageRequest(): SendUserMessageRequest {
  return { id: "", userId: 0n, type: 0, content: "", receiverUserIds: [], msgId: "" };
}

export const SendUserMessageRequest = {
  encode(message: SendUserMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== 0n) {
      if (BigInt.asUintN(64, message.userId) !== message.userId) {
        throw new globalThis.Error("value provided for field message.userId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.userId.toString());
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    writer.uint32(42).fork();
    for (const v of message.receiverUserIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field receiverUserIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    if (message.msgId !== "") {
      writer.uint32(50).string(message.msgId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendUserMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendUserMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag === 40) {
            message.receiverUserIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.receiverUserIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.msgId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendUserMessageRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? BigInt(object.userId) : 0n,
      type: isSet(object.type) ? messageTypeFromJSON(object.type) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      receiverUserIds: globalThis.Array.isArray(object?.receiverUserIds)
        ? object.receiverUserIds.map((e: any) => BigInt(e))
        : [],
      msgId: isSet(object.msgId) ? globalThis.String(object.msgId) : "",
    };
  },

  toJSON(message: SendUserMessageRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== 0n) {
      obj.userId = message.userId.toString();
    }
    if (message.type !== 0) {
      obj.type = messageTypeToJSON(message.type);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.receiverUserIds?.length) {
      obj.receiverUserIds = message.receiverUserIds.map((e) => e.toString());
    }
    if (message.msgId !== "") {
      obj.msgId = message.msgId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendUserMessageRequest>, I>>(base?: I): SendUserMessageRequest {
    return SendUserMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendUserMessageRequest>, I>>(object: I): SendUserMessageRequest {
    const message = createBaseSendUserMessageRequest();
    message.id = object.id ?? "";
    message.userId = object.userId ?? 0n;
    message.type = object.type ?? 0;
    message.content = object.content ?? "";
    message.receiverUserIds = object.receiverUserIds?.map((e) => e) || [];
    message.msgId = object.msgId ?? "";
    return message;
  },
};

function createBaseSendBotMessageRequest(): SendBotMessageRequest {
  return { id: "", senderId: 0n, type: 0, content: "", msgId: "" };
}

export const SendBotMessageRequest = {
  encode(message: SendBotMessageRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.senderId !== 0n) {
      if (BigInt.asIntN(64, message.senderId) !== message.senderId) {
        throw new globalThis.Error("value provided for field message.senderId of type int64 too large");
      }
      writer.uint32(16).int64(message.senderId.toString());
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.content !== "") {
      writer.uint32(34).string(message.content);
    }
    if (message.msgId !== "") {
      writer.uint32(42).string(message.msgId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendBotMessageRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendBotMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.senderId = longToBigint(reader.int64() as Long);
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.content = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.msgId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendBotMessageRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      senderId: isSet(object.senderId) ? BigInt(object.senderId) : 0n,
      type: isSet(object.type) ? messageTypeFromJSON(object.type) : 0,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      msgId: isSet(object.msgId) ? globalThis.String(object.msgId) : "",
    };
  },

  toJSON(message: SendBotMessageRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.senderId !== 0n) {
      obj.senderId = message.senderId.toString();
    }
    if (message.type !== 0) {
      obj.type = messageTypeToJSON(message.type);
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.msgId !== "") {
      obj.msgId = message.msgId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendBotMessageRequest>, I>>(base?: I): SendBotMessageRequest {
    return SendBotMessageRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendBotMessageRequest>, I>>(object: I): SendBotMessageRequest {
    const message = createBaseSendBotMessageRequest();
    message.id = object.id ?? "";
    message.senderId = object.senderId ?? 0n;
    message.type = object.type ?? 0;
    message.content = object.content ?? "";
    message.msgId = object.msgId ?? "";
    return message;
  },
};

function createBaseSendBotMessageResponse(): SendBotMessageResponse {
  return { items: [] };
}

export const SendBotMessageResponse = {
  encode(message: SendBotMessageResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      Message.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SendBotMessageResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendBotMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(Message.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendBotMessageResponse {
    return { items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => Message.fromJSON(e)) : [] };
  },

  toJSON(message: SendBotMessageResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => Message.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SendBotMessageResponse>, I>>(base?: I): SendBotMessageResponse {
    return SendBotMessageResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SendBotMessageResponse>, I>>(object: I): SendBotMessageResponse {
    const message = createBaseSendBotMessageResponse();
    message.items = object.items?.map((e) => Message.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAddUserRequest(): AddUserRequest {
  return { id: "", userIds: [] };
}

export const AddUserRequest = {
  encode(message: AddUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    writer.uint32(18).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag === 16) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddUserRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [],
    };
  },

  toJSON(message: AddUserRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddUserRequest>, I>>(base?: I): AddUserRequest {
    return AddUserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddUserRequest>, I>>(object: I): AddUserRequest {
    const message = createBaseAddUserRequest();
    message.id = object.id ?? "";
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseExitByIdsRequest(): ExitByIdsRequest {
  return { ids: [], userIds: [] };
}

export const ExitByIdsRequest = {
  encode(message: ExitByIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    writer.uint32(18).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ExitByIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExitByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
        case 2:
          if (tag === 16) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExitByIdsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [],
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [],
    };
  },

  toJSON(message: ExitByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExitByIdsRequest>, I>>(base?: I): ExitByIdsRequest {
    return ExitByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExitByIdsRequest>, I>>(object: I): ExitByIdsRequest {
    const message = createBaseExitByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseDropByIdsRequest(): DropByIdsRequest {
  return { ids: [] };
}

export const DropByIdsRequest = {
  encode(message: DropByIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DropByIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDropByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DropByIdsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: DropByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DropByIdsRequest>, I>>(base?: I): DropByIdsRequest {
    return DropByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DropByIdsRequest>, I>>(object: I): DropByIdsRequest {
    const message = createBaseDropByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseClearMessageByIdsRequest(): ClearMessageByIdsRequest {
  return { ids: [] };
}

export const ClearMessageByIdsRequest = {
  encode(message: ClearMessageByIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClearMessageByIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearMessageByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearMessageByIdsRequest {
    return { ids: globalThis.Array.isArray(object?.ids) ? object.ids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ClearMessageByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearMessageByIdsRequest>, I>>(base?: I): ClearMessageByIdsRequest {
    return ClearMessageByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearMessageByIdsRequest>, I>>(object: I): ClearMessageByIdsRequest {
    const message = createBaseClearMessageByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseClearMessageByUserIdsRequest(): ClearMessageByUserIdsRequest {
  return { userIds: [] };
}

export const ClearMessageByUserIdsRequest = {
  encode(message: ClearMessageByUserIdsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ClearMessageByUserIdsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClearMessageByUserIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 8) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClearMessageByUserIdsRequest {
    return { userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [] };
  },

  toJSON(message: ClearMessageByUserIdsRequest): unknown {
    const obj: any = {};
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClearMessageByUserIdsRequest>, I>>(base?: I): ClearMessageByUserIdsRequest {
    return ClearMessageByUserIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClearMessageByUserIdsRequest>, I>>(object: I): ClearMessageByUserIdsRequest {
    const message = createBaseClearMessageByUserIdsRequest();
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseCreateRequest(): CreateRequest {
  return { creatorId: 0n, businessType: 0, userIds: [] };
}

export const CreateRequest = {
  encode(message: CreateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.creatorId !== 0n) {
      if (BigInt.asUintN(64, message.creatorId) !== message.creatorId) {
        throw new globalThis.Error("value provided for field message.creatorId of type uint64 too large");
      }
      writer.uint32(8).uint64(message.creatorId.toString());
    }
    if (message.businessType !== 0) {
      writer.uint32(16).int32(message.businessType);
    }
    writer.uint32(26).fork();
    for (const v of message.userIds) {
      if (BigInt.asUintN(64, v) !== v) {
        throw new globalThis.Error("a value provided in array field userIds of type uint64 is too large");
      }
      writer.uint64(v.toString());
    }
    writer.ldelim();
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.creatorId = longToBigint(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.businessType = reader.int32();
          continue;
        case 3:
          if (tag === 24) {
            message.userIds.push(longToBigint(reader.uint64() as Long));

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.userIds.push(longToBigint(reader.uint64() as Long));
            }

            continue;
          }

          break;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequest {
    return {
      creatorId: isSet(object.creatorId) ? BigInt(object.creatorId) : 0n,
      businessType: isSet(object.businessType) ? globalThis.Number(object.businessType) : 0,
      userIds: globalThis.Array.isArray(object?.userIds) ? object.userIds.map((e: any) => BigInt(e)) : [],
    };
  },

  toJSON(message: CreateRequest): unknown {
    const obj: any = {};
    if (message.creatorId !== 0n) {
      obj.creatorId = message.creatorId.toString();
    }
    if (message.businessType !== 0) {
      obj.businessType = Math.round(message.businessType);
    }
    if (message.userIds?.length) {
      obj.userIds = message.userIds.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRequest>, I>>(base?: I): CreateRequest {
    return CreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRequest>, I>>(object: I): CreateRequest {
    const message = createBaseCreateRequest();
    message.creatorId = object.creatorId ?? 0n;
    message.businessType = object.businessType ?? 0;
    message.userIds = object.userIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseChatConfigRequest(): ChatConfigRequest {
  return { id: "", userId: 0n, changeField: "", value: "" };
}

export const ChatConfigRequest = {
  encode(message: ChatConfigRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== 0n) {
      if (BigInt.asUintN(64, message.userId) !== message.userId) {
        throw new globalThis.Error("value provided for field message.userId of type uint64 too large");
      }
      writer.uint32(16).uint64(message.userId.toString());
    }
    if (message.changeField !== "") {
      writer.uint32(26).string(message.changeField);
    }
    if (message.value !== "") {
      writer.uint32(34).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatConfigRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatConfigRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.userId = longToBigint(reader.uint64() as Long);
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.changeField = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatConfigRequest {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      userId: isSet(object.userId) ? BigInt(object.userId) : 0n,
      changeField: isSet(object.changeField) ? globalThis.String(object.changeField) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ChatConfigRequest): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.userId !== 0n) {
      obj.userId = message.userId.toString();
    }
    if (message.changeField !== "") {
      obj.changeField = message.changeField;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatConfigRequest>, I>>(base?: I): ChatConfigRequest {
    return ChatConfigRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatConfigRequest>, I>>(object: I): ChatConfigRequest {
    const message = createBaseChatConfigRequest();
    message.id = object.id ?? "";
    message.userId = object.userId ?? 0n;
    message.changeField = object.changeField ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseChatConfigResponse(): ChatConfigResponse {
  return { id: "", isTop: 0, isMute: 0, isShow: 0, isHide: 0 };
}

export const ChatConfigResponse = {
  encode(message: ChatConfigResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.isTop !== 0) {
      writer.uint32(16).int32(message.isTop);
    }
    if (message.isMute !== 0) {
      writer.uint32(24).int32(message.isMute);
    }
    if (message.isShow !== 0) {
      writer.uint32(32).int32(message.isShow);
    }
    if (message.isHide !== 0) {
      writer.uint32(40).int32(message.isHide);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ChatConfigResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChatConfigResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isTop = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isMute = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isShow = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isHide = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChatConfigResponse {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      isTop: isSet(object.isTop) ? globalThis.Number(object.isTop) : 0,
      isMute: isSet(object.isMute) ? globalThis.Number(object.isMute) : 0,
      isShow: isSet(object.isShow) ? globalThis.Number(object.isShow) : 0,
      isHide: isSet(object.isHide) ? globalThis.Number(object.isHide) : 0,
    };
  },

  toJSON(message: ChatConfigResponse): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.isTop !== 0) {
      obj.isTop = Math.round(message.isTop);
    }
    if (message.isMute !== 0) {
      obj.isMute = Math.round(message.isMute);
    }
    if (message.isShow !== 0) {
      obj.isShow = Math.round(message.isShow);
    }
    if (message.isHide !== 0) {
      obj.isHide = Math.round(message.isHide);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChatConfigResponse>, I>>(base?: I): ChatConfigResponse {
    return ChatConfigResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChatConfigResponse>, I>>(object: I): ChatConfigResponse {
    const message = createBaseChatConfigResponse();
    message.id = object.id ?? "";
    message.isTop = object.isTop ?? 0;
    message.isMute = object.isMute ?? 0;
    message.isShow = object.isShow ?? 0;
    message.isHide = object.isHide ?? 0;
    return message;
  },
};

export type ChatProtoService = typeof ChatProtoService;
export const ChatProtoService = {
  findByIds: {
    path: "/chat_proto.ChatProto/FindByIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: FindByIdsRequest) => Buffer.from(FindByIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FindByIdsRequest.decode(value),
    responseSerialize: (value: ChatListResponse) => Buffer.from(ChatListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChatListResponse.decode(value),
  },
  /** 发送消息 */
  sendUserMessage: {
    path: "/chat_proto.ChatProto/SendUserMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendUserMessageRequest) => Buffer.from(SendUserMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendUserMessageRequest.decode(value),
    responseSerialize: (value: Message) => Buffer.from(Message.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Message.decode(value),
  },
  /** 机器人发送消息 todo */
  sendBotMessage: {
    path: "/chat_proto.ChatProto/SendBotMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SendBotMessageRequest) => Buffer.from(SendBotMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SendBotMessageRequest.decode(value),
    responseSerialize: (value: Message) => Buffer.from(Message.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Message.decode(value),
  },
  /** 增加用户 */
  addUsers: {
    path: "/chat_proto.ChatProto/AddUsers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddUserRequest) => Buffer.from(AddUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddUserRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 移除用户 */
  removeUsers: {
    path: "/chat_proto.ChatProto/RemoveUsers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveUserRequest) => Buffer.from(RemoveUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveUserRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 改变创建者 */
  changeCreator: {
    path: "/chat_proto.ChatProto/ChangeCreator",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChangeCreatorRequest) => Buffer.from(ChangeCreatorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChangeCreatorRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 创建会话 */
  create: {
    path: "/chat_proto.ChatProto/Create",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRequest) => Buffer.from(CreateRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateRequest.decode(value),
    responseSerialize: (value: Chat) => Buffer.from(Chat.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Chat.decode(value),
  },
  /** 退出会话 */
  exitByIds: {
    path: "/chat_proto.ChatProto/ExitByIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExitByIdsRequest) => Buffer.from(ExitByIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExitByIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 删除会话 */
  dropByIds: {
    path: "/chat_proto.ChatProto/DropByIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DropByIdsRequest) => Buffer.from(DropByIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DropByIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 清空会话消息 */
  clearMessageByIds: {
    path: "/chat_proto.ChatProto/ClearMessageByIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearMessageByIdsRequest) => Buffer.from(ClearMessageByIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClearMessageByIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 删除某用户所有消息 */
  clearMessageByUserIds: {
    path: "/chat_proto.ChatProto/ClearMessageByUserIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ClearMessageByUserIdsRequest) =>
      Buffer.from(ClearMessageByUserIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ClearMessageByUserIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  removeUserByIds: {
    path: "/chat_proto.ChatProto/RemoveUserByIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveUserByIdsRequest) => Buffer.from(RemoveUserByIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveUserByIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  removeUserByUserIds: {
    path: "/chat_proto.ChatProto/RemoveUserByUserIds",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveUserByUserIdsRequest) =>
      Buffer.from(RemoveUserByUserIdsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveUserByUserIdsRequest.decode(value),
    responseSerialize: (value: boolean | undefined) =>
      Buffer.from(BoolValue.encode({ value: value ?? false }).finish()),
    responseDeserialize: (value: Buffer) => BoolValue.decode(value).value,
  },
  /** 修改 会话配置 */
  changeChatConfig: {
    path: "/chat_proto.ChatProto/changeChatConfig",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ChatConfigRequest) => Buffer.from(ChatConfigRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatConfigRequest.decode(value),
    responseSerialize: (value: ChatConfigResponse) => Buffer.from(ChatConfigResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChatConfigResponse.decode(value),
  },
} as const;

export interface ChatProtoServer extends UntypedServiceImplementation {
  findByIds: handleUnaryCall<FindByIdsRequest, ChatListResponse>;
  /** 发送消息 */
  sendUserMessage: handleUnaryCall<SendUserMessageRequest, Message>;
  /** 机器人发送消息 todo */
  sendBotMessage: handleUnaryCall<SendBotMessageRequest, Message>;
  /** 增加用户 */
  addUsers: handleUnaryCall<AddUserRequest, boolean | undefined>;
  /** 移除用户 */
  removeUsers: handleUnaryCall<RemoveUserRequest, boolean | undefined>;
  /** 改变创建者 */
  changeCreator: handleUnaryCall<ChangeCreatorRequest, boolean | undefined>;
  /** 创建会话 */
  create: handleUnaryCall<CreateRequest, Chat>;
  /** 退出会话 */
  exitByIds: handleUnaryCall<ExitByIdsRequest, boolean | undefined>;
  /** 删除会话 */
  dropByIds: handleUnaryCall<DropByIdsRequest, boolean | undefined>;
  /** 清空会话消息 */
  clearMessageByIds: handleUnaryCall<ClearMessageByIdsRequest, boolean | undefined>;
  /** 删除某用户所有消息 */
  clearMessageByUserIds: handleUnaryCall<ClearMessageByUserIdsRequest, boolean | undefined>;
  removeUserByIds: handleUnaryCall<RemoveUserByIdsRequest, boolean | undefined>;
  removeUserByUserIds: handleUnaryCall<RemoveUserByUserIdsRequest, boolean | undefined>;
  /** 修改 会话配置 */
  changeChatConfig: handleUnaryCall<ChatConfigRequest, ChatConfigResponse>;
}

export interface ChatProtoClient extends Client {
  findByIds(
    request: FindByIdsRequest,
    callback: (error: ServiceError | null, response: ChatListResponse) => void,
  ): ClientUnaryCall;
  findByIds(
    request: FindByIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChatListResponse) => void,
  ): ClientUnaryCall;
  findByIds(
    request: FindByIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChatListResponse) => void,
  ): ClientUnaryCall;
  /** 发送消息 */
  sendUserMessage(
    request: SendUserMessageRequest,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  sendUserMessage(
    request: SendUserMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  sendUserMessage(
    request: SendUserMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  /** 机器人发送消息 todo */
  sendBotMessage(
    request: SendBotMessageRequest,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  sendBotMessage(
    request: SendBotMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  sendBotMessage(
    request: SendBotMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Message) => void,
  ): ClientUnaryCall;
  /** 增加用户 */
  addUsers(
    request: AddUserRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  addUsers(
    request: AddUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  addUsers(
    request: AddUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 移除用户 */
  removeUsers(
    request: RemoveUserRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUsers(
    request: RemoveUserRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUsers(
    request: RemoveUserRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 改变创建者 */
  changeCreator(
    request: ChangeCreatorRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  changeCreator(
    request: ChangeCreatorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  changeCreator(
    request: ChangeCreatorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 创建会话 */
  create(request: CreateRequest, callback: (error: ServiceError | null, response: Chat) => void): ClientUnaryCall;
  create(
    request: CreateRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Chat) => void,
  ): ClientUnaryCall;
  create(
    request: CreateRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Chat) => void,
  ): ClientUnaryCall;
  /** 退出会话 */
  exitByIds(
    request: ExitByIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  exitByIds(
    request: ExitByIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  exitByIds(
    request: ExitByIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 删除会话 */
  dropByIds(
    request: DropByIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  dropByIds(
    request: DropByIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  dropByIds(
    request: DropByIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 清空会话消息 */
  clearMessageByIds(
    request: ClearMessageByIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  clearMessageByIds(
    request: ClearMessageByIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  clearMessageByIds(
    request: ClearMessageByIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 删除某用户所有消息 */
  clearMessageByUserIds(
    request: ClearMessageByUserIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  clearMessageByUserIds(
    request: ClearMessageByUserIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  clearMessageByUserIds(
    request: ClearMessageByUserIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByIds(
    request: RemoveUserByIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByIds(
    request: RemoveUserByIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByIds(
    request: RemoveUserByIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByUserIds(
    request: RemoveUserByUserIdsRequest,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByUserIds(
    request: RemoveUserByUserIdsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  removeUserByUserIds(
    request: RemoveUserByUserIdsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: boolean | undefined) => void,
  ): ClientUnaryCall;
  /** 修改 会话配置 */
  changeChatConfig(
    request: ChatConfigRequest,
    callback: (error: ServiceError | null, response: ChatConfigResponse) => void,
  ): ClientUnaryCall;
  changeChatConfig(
    request: ChatConfigRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ChatConfigResponse) => void,
  ): ClientUnaryCall;
  changeChatConfig(
    request: ChatConfigRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ChatConfigResponse) => void,
  ): ClientUnaryCall;
}

export const ChatProtoClient = makeGenericClientConstructor(ChatProtoService, "chat_proto.ChatProto") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): ChatProtoClient;
  service: typeof ChatProtoService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToBigint(long: Long) {
  return BigInt(long.toString());
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
